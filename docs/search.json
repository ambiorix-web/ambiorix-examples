[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Documentation",
    "section": "",
    "text": "Welcome to the docs for the ✨ambiorix-examples✨\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n\n\n\n\n\n\n\n00: getting started\n\n\nInstallation\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n01: hello, world!\n\n\nWhere else to start? :)\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n02: static files\n\n\nServe static files\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n03: basic routing\n\n\nAn intro to routes\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n04: simple json api\n\n\nBuild a simple API\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n05: router\n\n\nWhat’s a router?\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n06: multi-router\n\n\nMount multiple routers\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n07: dynamic rendering\n\n\nDynamically render templates\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n08: datatables\n\n\nR users love tables!\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n09: goals\n\n\nA CRUD application backend\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n10: live reloading\n\n\nManual reloading is such a pain!\n\n\n\nKennedy Mwavu\n\n\nJul 10, 2024\n\n\n\n\n\n\n\n\n\n\n\n11: csv & xlsx upload\n\n\nfile upload to an ambiorix API\n\n\n\nKennedy Mwavu\n\n\nJul 19, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/01_hello_world/index.html",
    "href": "posts/01_hello_world/index.html",
    "title": "01: hello, world!",
    "section": "",
    "text": "cd into the 01_hello_world/ dir:\ncd 01_hello_world/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nindex.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/01_hello_world/index.html#run-app",
    "href": "posts/01_hello_world/index.html#run-app",
    "title": "01: hello, world!",
    "section": "",
    "text": "cd into the 01_hello_world/ dir:\ncd 01_hello_world/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nindex.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/01_hello_world/index.html#explanation",
    "href": "posts/01_hello_world/index.html#explanation",
    "title": "01: hello, world!",
    "section": "Explanation",
    "text": "Explanation\nThis app starts a server and listens on port 3000 for connections.\nIt has 2 endpoints:\n\n/: localhost:3000/\n/about: localhost:3000/about\n\nFor every other path, it will response with a 404 Not Found."
  },
  {
    "objectID": "posts/01_hello_world/index.html#static-files",
    "href": "posts/01_hello_world/index.html#static-files",
    "title": "01: hello, world!",
    "section": "Static files",
    "text": "Static files\nLearn how to serve ✨Static Files✨ using ambiorix."
  },
  {
    "objectID": "posts/10_live_reloading/index.html",
    "href": "posts/10_live_reloading/index.html",
    "title": "10: live reloading",
    "section": "",
    "text": "When building applications (whether backend or frontend), it gets tiring to manually stop & restart the app when you make changes to the source code.\nThis guide shows you how you can monitor files for changes and have the app restart automatically.\n\n\n\n\n\n\nNote\n\n\n\nThis is not something specific to ambiorix, but it is extremely useful during my development process, so I saw it a good idea to have it included as part of the examples."
  },
  {
    "objectID": "posts/10_live_reloading/index.html#live-reloading",
    "href": "posts/10_live_reloading/index.html#live-reloading",
    "title": "10: live reloading",
    "section": "",
    "text": "When building applications (whether backend or frontend), it gets tiring to manually stop & restart the app when you make changes to the source code.\nThis guide shows you how you can monitor files for changes and have the app restart automatically.\n\n\n\n\n\n\nNote\n\n\n\nThis is not something specific to ambiorix, but it is extremely useful during my development process, so I saw it a good idea to have it included as part of the examples."
  },
  {
    "objectID": "posts/10_live_reloading/index.html#prerequisites",
    "href": "posts/10_live_reloading/index.html#prerequisites",
    "title": "10: live reloading",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nA working installation of nodejs & npm\n\nIn case you’d like to know, we won’t be writing any JavaScript."
  },
  {
    "objectID": "posts/10_live_reloading/index.html#setup",
    "href": "posts/10_live_reloading/index.html#setup",
    "title": "10: live reloading",
    "section": "Setup",
    "text": "Setup\n\nYou of course need to have an app. You can use any of the code in the previous examples. We will use a simple server.R file, which is also the entrypoint:\n  library(ambiorix)\n\n  app &lt;- Ambiorix$new()\n\n  app$get(\"/\", \\(req, res){\n    res$send(\"Using {ambiorix}!\")\n  })\n\n  app$get(\"/about\", \\(req, res){\n    res$text(\"About\")\n  })\n\n  app$start()\nChange to your project’s root dir.\ncd myproject\nInitialize an npm project & create the package.json file:\nnpm init -y\nThe -y flag accepts the default npm setup.\nInstall nodemon as a dev dependency:\nnpm i -D nodemon\nCreate the file nodemon.json at the root dir of your project and paste this in it:\n{\n  \"execMap\": {\n    \"R\": \"Rscript\"\n  },\n  \"ext\": \"*\"\n}\nThis specifies an executable mapping for .R files: Rscript.\nIt also tells nodemon to monitor all files (*) for changes. You can as well monitor specific file extensions. For example to only watch .R, .html, .css & .js files, change ext to:\n\"ext\": \"R,html,css,js\"\nOpen package.json and edit the “scripts” section to this:\n\"scripts\": {\n  \"dev\": \"nodemon --signal SIGTERM server.R\"\n}\nThis tells nodemon to re-run the file server.R when changes happen.\nThe --signal SIGTERM is basically telling nodemon to send a termination signal to the previously running program before spawning a new one. This is especially useful for freeing the port the app is running on, and then re-using it again.\nRun the app:\nnpm run dev\nThis runs the dev script which starts, stops & restarts your app when changes occurs.\nNow try making some changes to your source code and enjoy the experience.\nWhen working on the backend, you don’t want a browser tab to open each time the app is restarted since you will mostly be sending requests via postman, so you will set start(open = FALSE) in your server.R:\n  library(ambiorix)\n\n  app &lt;- Ambiorix$new()\n\n  app$get(\"/\", \\(req, res){\n    res$send(\"Using {ambiorix}!\")\n  })\n\n  app$get(\"/about\", \\(req, res){\n    res$text(\"About\")\n  })\n\n  app$start(open = FALSE)\nTo stop npm, press CTRL + C.\nAdd node_modules/ to your .gitignore file.\nYou can as well add nodemon.json, package-lock.json, & package.json to .gitignore since they’re just used for development purposes. I have commited them for this example just so you can see their contents."
  },
  {
    "objectID": "posts/06_multi_router/index.html",
    "href": "posts/06_multi_router/index.html",
    "title": "06: multi-router",
    "section": "",
    "text": "cd into the 06_multi_router/ dir:\ncd 06_multi_router/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nserver.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/06_multi_router/index.html#run-app",
    "href": "posts/06_multi_router/index.html#run-app",
    "title": "06: multi-router",
    "section": "",
    "text": "cd into the 06_multi_router/ dir:\ncd 06_multi_router/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nserver.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/06_multi_router/index.html#explanation",
    "href": "posts/06_multi_router/index.html#explanation",
    "title": "06: multi-router",
    "section": "Explanation",
    "text": "Explanation\nThis app starts a server and listens on port 3000 for connections.\nYou can have multiple routers mounted onto ambiorix::Ambiorix via the use() method.\nIn this example, I show how you can version your api.\nRemember, ambiorix is unopinionated. This is just my way of doing things.\nYou’ll see that using {box} is the easiest way to split up & organize your files & folders.\nThis is the directory structure that I’ve used:\n.\n├── api\n│   ├── members.R\n│   ├── v1\n│   │   ├── members\n│   │   │   ├── controllers.R\n│   │   │   ├── create_new_member.R\n│   │   │   ├── delete_member.R\n│   │   │   ├── get_all_members.R\n│   │   │   ├── get_member_by_id.R\n│   │   │   └── update_member_info.R\n│   │   └── members.R\n│   └── v2\n│       ├── members\n│       │   ├── controllers.R\n│       │   ├── create_new_member.R\n│       │   ├── delete_member.R\n│       │   ├── get_all_members.R\n│       │   ├── get_member_by_id.R\n│       │   └── update_member_info.R\n│       └── members.R\n├── index.R\n└── README.md\nThis is how server.R looks like:\nbox::use(\n  ambiorix[Ambiorix],\n  . / api / members\n)\n\nAmbiorix$\n  new()$\n  listen(port = 3000L)$\n  use(members$v1)$ # mount API v1 members' router\n  use(members$v2)$ # mount API v2 members' router\n  start(open = FALSE)\nOnce you run the app, you should be able to perform requests on http://localhost:3000/api/v*/members, eg.\n\nGET request on http://localhost:3000/api/v1/members\nPUT request on http://localhost:3000/api/v2/members/:3\n\n… and so on.\nCheckout the routers in these files:\n\n./api/v1/members.R\n./api/v2/members.R"
  },
  {
    "objectID": "posts/06_multi_router/index.html#dynamic-rendering",
    "href": "posts/06_multi_router/index.html#dynamic-rendering",
    "title": "06: multi-router",
    "section": "Dynamic rendering",
    "text": "Dynamic rendering\nAre you ready for some frontend fun? See ✨dynamic rendering✨."
  },
  {
    "objectID": "posts/04_simple_json_api/index.html",
    "href": "posts/04_simple_json_api/index.html",
    "title": "04: simple json api",
    "section": "",
    "text": "cd into the 04_simple_json_api/ dir:\ncd 04_simple_json_api/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nserver.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/04_simple_json_api/index.html#run-app",
    "href": "posts/04_simple_json_api/index.html#run-app",
    "title": "04: simple json api",
    "section": "",
    "text": "cd into the 04_simple_json_api/ dir:\ncd 04_simple_json_api/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nserver.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/04_simple_json_api/index.html#explanation",
    "href": "posts/04_simple_json_api/index.html#explanation",
    "title": "04: simple json api",
    "section": "Explanation",
    "text": "Explanation\nThis app starts a server and listens on port 3000 for connections.\nIt has two endpoints:\n\n/api/members\n/api/members/:id\n\nIdeally, the backend works hand-in-hand with the database. But for the sake of simplicity, let’s hardcode a list of members:\nmembers &lt;- data.frame(\n  id = as.character(1:3),\n  name = c(\"John Doe\", \"Bob Williams\", \"Shannon Jackson\"),\n  email = c(\"john@gmail.com\", \"bob@gmail.com\", \"shannon@gmail.com\"),\n  status = c(\"active\", \"inactive\", \"active\")\n)\nYou don’t have to worry about converting members into JSON because the res$json() method does it for you.\nCreate a GET request to get all members:\napp$get(\"/api/members\", \\(req, res) {\n  res$json(members)\n})\n\n\n\nGET /api/members\n\n\nCreate a GET request to get a single member by id:\napp$get(\"/api/members/:id\", \\(req, res) {\n  # get the supplied id:\n  member_id &lt;- req$params$id\n\n  # filter member with that id:\n  found &lt;- members |&gt; dplyr::filter(id == member_id)\n\n  res$json(found)\n})\n\n\n\nGET /api/members/:id\n\n\nYou can also dictate how the response changes if no member is found:\n# get a single member:\napp$get(\"/api/members/:id\", \\(req, res) {\n  # get the supplied id:\n  member_id &lt;- req$params$id\n\n  # filter member with that id:\n  found &lt;- members |&gt; dplyr::filter(id == member_id)\n\n  # if a member with that id was found, return the member:\n  if (nrow(found) &gt; 0) {\n    return(res$json(found))\n  }\n\n  # otherwise, change response status to 400 (Bad Request)\n  # and provide a message:\n  msg &lt;- list(msg = sprintf(\"No member with the id of %s\", member_id))\n  res$set_status(400L)$json(msg)\n})\n\n\n\nGET /api/members/:id\n\n\nA POST request to create a new member:\napp$post(\"/api/members\", \\(req, res) {\n  # parse form-data:\n  body &lt;- parse_multipart(req)\n\n  # details of the new member:\n  new_member &lt;- data.frame(\n    id = uuid::UUIDgenerate(),\n    name = body$name,\n    email = body$email,\n    status = body$status\n  )\n\n  # save new member:\n  members &lt;&lt;- dplyr::bind_rows(members, new_member)\n\n  # respond with a message and details of the newly created member:\n  response &lt;- list(\n    msg = \"Member created successfully!\",\n    member = new_member\n  )\n\n  res$json(response)\n})\n\n\n\nPOST /api/members\n\n\nYou can of course ensure all the details are sent (name, email & status) before creating the new member:\napp$post(\"/api/members\", \\(req, res) {\n  # parse form-data:\n  body &lt;- parse_multipart(req)\n\n  name &lt;- body$name\n  email &lt;- body$email\n  status &lt;- body$status\n\n  # require all member details:\n  if (is.null(name) || is.null(email) || is.null(status)) {\n    msg &lt;- list(msg = \"Please include a name, email & status\")\n    return(res$set_status(400L)$json(msg))\n  }\n\n  # details of the new member:\n  new_member &lt;- data.frame(\n    id = uuid::UUIDgenerate(),\n    name = name,\n    email = email,\n    status = status\n  )\n\n  # save new member:\n  members &lt;&lt;- dplyr::bind_rows(members, new_member)\n\n  # respond with a message and details of the newly created member:\n  response &lt;- list(\n    msg = \"Member created successfully!\",\n    member = new_member\n  )\n\n  res$json(response)\n})\n\n\n\nPOST /api/members\n\n\nCreate a PUT request to update a member:\napp$put(\"/api/members/:id\", \\(req, res) {\n  # get the supplied id:\n  member_id &lt;- req$params$id\n\n  # filter member with that id:\n  found &lt;- members |&gt; dplyr::filter(id == member_id)\n\n  # if a member with that id is NOT found, change response status\n  # and provide a message:\n  if (nrow(found) == 0) {\n    msg &lt;- list(msg = sprintf(\"No member with the id of %s\", member_id))\n    return(res$set_status(400L)$json(msg))\n  }\n\n  # otherwise, proceed to update member:\n  body &lt;- parse_multipart(req)\n\n  # only update provided fields:\n  found$name &lt;- body$name %||% found$name\n  found$email &lt;- body$email %||% found$email\n  found$status &lt;- body$status %||% found$status\n\n  members[members$id == found$id, ] &lt;- found\n\n  response &lt;- list(\n    msg = \"Member updated successfully\",\n    member = found\n  )\n  res$json(response)\n})\n\n\n\nPUT /api/members/:id\n\n\nCreate a delete request to, well, delete a member:\napp$delete(\"/api/members/:id\", \\(req, res) {\n  # get the supplied id:\n  member_id &lt;- req$params$id\n\n  # filter member with that id:\n  found &lt;- members |&gt; dplyr::filter(id == member_id)\n\n  # if a member with that id is NOT found, change response status\n  # and provide a message:\n  if (nrow(found) == 0) {\n    msg &lt;- list(msg = sprintf(\"No member with the id of %s\", member_id))\n    return(res$set_status(400L)$json(msg))\n  }\n\n  # otherwise, proceed to delete member:\n  members &lt;&lt;- members |&gt; dplyr::filter(id != member_id)\n\n  response &lt;- list(\n    msg = \"Member deleted successfully\",\n    members = members\n  )\n  res$json(response)\n})\n\n\n\nDELETE /api/members/:id"
  },
  {
    "objectID": "posts/04_simple_json_api/index.html#router",
    "href": "posts/04_simple_json_api/index.html#router",
    "title": "04: simple json api",
    "section": "Router",
    "text": "Router\nThings are getting out of hand in server.R. Take a look at ✨routers✨."
  },
  {
    "objectID": "posts/11_csv_xlsx_upload/index.html",
    "href": "posts/11_csv_xlsx_upload/index.html",
    "title": "11: csv & xlsx upload",
    "section": "",
    "text": "cd into the 11_csv_xlsx_upload/ dir:\ncd 11_csv_xlsx_upload/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nserver.R is the entry point. To start the API, run this on the terminal:\nRscript server.R"
  },
  {
    "objectID": "posts/11_csv_xlsx_upload/index.html#skeleton",
    "href": "posts/11_csv_xlsx_upload/index.html#skeleton",
    "title": "11: csv & xlsx upload",
    "section": "Skeleton",
    "text": "Skeleton\nNext, let’s define the API skeleton:\n1app &lt;- Ambiorix$new(port = 3000, host = \"127.0.0.1\")\n2app$limit &lt;- 35 * 1024 * 1024\n\napp$\n3  set_error(error_handler)$\n4  get(\"/\", home_get)$\n5  post(\"/csv\", csv_upload_post)$\n6  post(\"/xlsx\", xlsx_upload_post)$\n7  start()\n\n1\n\nInitialize a new ambiorix app. Set port & host to run app on.\n\n2\n\nIncrease max body size to 35 MB. Think of this as the max file upload size for now.\n\n3\n\nSet an error handler for the API.\n\n4\n\nAdd handler for requests at /.\n\n5\n\nAdd handler for requests at /csv.\n\n6\n\nAdd handler for requests at /xlsx.\n\n7\n\nStart API.\n\n\nNow, let’s create the handlers."
  },
  {
    "objectID": "posts/11_csv_xlsx_upload/index.html#error-handler",
    "href": "posts/11_csv_xlsx_upload/index.html#error-handler",
    "title": "11: csv & xlsx upload",
    "section": "Error handler",
    "text": "Error handler\nI’ve made it a habit to always have an error handler for my APIs. Ideally, this is where you log any server errors that occurred, either due to failed operations or bugs.\n#' 500 error handler middleware\n#'\n#' @param req Request object.\n#' @param res Response object.\n#' @param error Error object. See [stop()].\n#' @return `res$json()`\n#' @export\nerror_handler &lt;- \\(req, res, error = NULL) {\n  if (!is.null(error)) {\n    msg &lt;- conditionMessage(error)\n    cli_alert_danger(text = msg)\n  }\n\n  response &lt;- list(\n    code = 500L,\n    msg = \"A server error occurred!\"\n  )\n\n  res$set_status(500L)$json(response)\n}"
  },
  {
    "objectID": "posts/11_csv_xlsx_upload/index.html#hello-world",
    "href": "posts/11_csv_xlsx_upload/index.html#hello-world",
    "title": "11: csv & xlsx upload",
    "section": "Hello, World!",
    "text": "Hello, World!\nAre you even a real programmer if you don’t always start with a “Hello, World”?\n#' Handle GET at '/'\n#'\n#' @param req Request object.\n#' @param res Response object.\n#' @return `res$json()`\n#' @export\nhome_get &lt;- \\(req, res) {\n  response &lt;- list(\n    code = 200L,\n    msg = \"hello, world!\"\n  )\n\n  res$json(response)\n}"
  },
  {
    "objectID": "posts/11_csv_xlsx_upload/index.html#csv-upload",
    "href": "posts/11_csv_xlsx_upload/index.html#csv-upload",
    "title": "11: csv & xlsx upload",
    "section": "csv upload",
    "text": "csv upload\nWe’re finally at the juicy part of this post!\n#' Handle POST at '/csv'\n#'\n#' @param req Request object.\n#' @param res Response object.\n#' @return `res$json()`\n#' @export\ncsv_upload_post &lt;- \\(req, res) {\n1  body &lt;- req$rook.input$read()\n\n2  response_400 &lt;- list(\n    code = 400L,\n    msg = \"please upload a csv file with the key 'file' in the request body\"\n  )\n\n  # if the req body is empty, return a 400:\n3  empty &lt;- length(body) == 0L\n  if (empty) {\n    return(\n      res$set_status(400L)$json(response_400)\n    )\n  }\n\n4  postdata &lt;- parse_http(\n    body = body,\n    content_type = req$CONTENT_TYPE\n  )\n\n5  file_details &lt;- postdata$file\n\n  # check 'content_type' of file:\n6  ok &lt;- identical(\n    x = file_details$content_type,\n    y = \"text/csv\"\n  )\n\n  if (!ok) {\n    return(\n      res$set_status(400L)$json(response_400)\n    )\n  }\n\n  # write file temporarily:\n7  temp &lt;- tempfile(fileext = \".csv\")\n  on.exit(unlink(x = temp))\n  writeBin(object = file_details$value, con = temp)\n\n  # read file:\n8  x &lt;- fread(file = temp)\n9  print(x)\n\n10  response &lt;- list(\n    code = 200L,\n    msg = \"file uploaded!\"\n  )\n\n  res$json(response)\n}\n\n1\n\nRead the request body.\n\n2\n\nCreate a bad request response: response_400.\n\n3\n\nIf the request body is empty, return response_400.\n\n4\n\nParse the body into a named list of key-value pairs. POST request variables are stored as key-value pairs in the request body.\n\n5\n\nGet the variable/field named file from the list.\n\n6\n\nIf the content type of the file is not text/csv, return response_400. To learn about common mime types, refer to MIME_types.\n\n7\n\nTemporarily write the file to disk.\n\n8\n\nRead the file.\n\n9\n\nPrint the data.table.\n\n10\n\nReturn a 200 success response."
  },
  {
    "objectID": "posts/11_csv_xlsx_upload/index.html#xlsx-upload",
    "href": "posts/11_csv_xlsx_upload/index.html#xlsx-upload",
    "title": "11: csv & xlsx upload",
    "section": "xlsx upload",
    "text": "xlsx upload\nThis is almost identical to how we’ve handled the csv file upload, except that we are now working with xlsx files.\n#' Handle POST at '/xlsx'\n#'\n#' @param req Request object.\n#' @param res Response object.\n#' @return `res$json()`\n#' @export\nxlsx_upload_post &lt;- \\(req, res) {\n  body &lt;- req$rook.input$read()\n\n  response_400 &lt;- list(\n    code = 400L,\n    msg = \"please upload an xlsx file with the key 'file' in the request body\"\n  )\n\n  # if the req body is empty, return a 400:\n  empty &lt;- length(body) == 0L\n  if (empty) {\n    return(\n      res$set_status(400L)$json(response_400)\n    )\n  }\n\n  postdata &lt;- parse_http(\n    body = body,\n    content_type = req$CONTENT_TYPE\n  )\n\n  file_details &lt;- postdata$file\n\n  # check 'content_type' of file:\n  ok &lt;- identical(\n    x = file_details$content_type,\n    y = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n  )\n\n  if (!ok) {\n    return(\n      res$set_status(400L)$json(response_400)\n    )\n  }\n\n  # write file temporarily:\n  temp &lt;- tempfile(fileext = \".xlsx\")\n  on.exit(unlink(x = temp))\n  writeBin(object = file_details$value, con = temp)\n\n  # read file:\n  x &lt;- read_xlsx(path = temp)\n  print(x)\n\n  response &lt;- list(\n    code = 200L,\n    msg = \"file uploaded!\"\n  )\n\n  res$json(response)\n}"
  },
  {
    "objectID": "posts/11_csv_xlsx_upload/index.html#test",
    "href": "posts/11_csv_xlsx_upload/index.html#test",
    "title": "11: csv & xlsx upload",
    "section": "Test",
    "text": "Test\nThis example comes with:\n\niris.csv: A csv test file.\niris.xlsx: An xlsx test file.\nexample.R: An R script showing how you can make requests to the API using R.\n\nTo make requests to the API, you can either use postman or open another R session in the same working directory as this example and run example.R:\n\ncsvxlsx\n\n\nbox::use(\n  curl[form_file],\n  httr2[\n    request,\n    req_perform,\n    req_url_path,\n    last_response,\n    resp_body_json,\n    req_body_multipart,\n  ]\n)\n\nbase_url &lt;- \"http://127.0.0.1:3000\"\nfile &lt;- form_file(\n  path = \"iris.csv\",\n  type = \"text/csv\",\n  name = \"iris.csv\"\n)\n\nreq &lt;- request(base_url = base_url) |&gt;\n  req_url_path(\"/csv\") |&gt;\n  req_body_multipart(file = file)\n\n# use `tryCatch()` in case an error occurs while performing the request:\ntryCatch(\n  expr = req |&gt;\n    req_perform() |&gt;\n    resp_body_json(),\n  error = \\(e) {\n    print(\"An error occurred!\")\n    error &lt;- last_response() |&gt; resp_body_json()\n    print(error)\n  }\n)\n\n\nbox::use(\n  curl[form_file],\n  httr2[\n    request,\n    req_perform,\n    req_url_path,\n    last_response,\n    resp_body_json,\n    req_body_multipart,\n  ]\n)\n\nbase_url &lt;- \"http://127.0.0.1:3000\"\nfile &lt;- form_file(\n  path = \"iris.xlsx\",\n  type = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n  name = \"iris.xlsx\"\n)\n\nreq &lt;- request(base_url = base_url) |&gt;\n  req_url_path(\"/xlsx\") |&gt;\n  req_body_multipart(file = file)\n\n# use `tryCatch()` in case an error occurs while performing the request:\ntryCatch(\n  expr = req |&gt;\n    req_perform() |&gt;\n    resp_body_json(),\n  error = \\(e) {\n    print(\"An error occurred!\")\n    error &lt;- last_response() |&gt; resp_body_json()\n    print(error)\n  }\n)"
  },
  {
    "objectID": "posts/00_getting_started/index.html",
    "href": "posts/00_getting_started/index.html",
    "title": "00: getting started",
    "section": "",
    "text": "Clone the repo:\ngit clone git@github.com:kennedymwavu/ambiorix-examples.git\ncd into the root dir:\ncd ambiorix-examples\nAll the examples assume you’re in this directory."
  },
  {
    "objectID": "posts/00_getting_started/index.html#installation",
    "href": "posts/00_getting_started/index.html#installation",
    "title": "00: getting started",
    "section": "",
    "text": "Clone the repo:\ngit clone git@github.com:kennedymwavu/ambiorix-examples.git\ncd into the root dir:\ncd ambiorix-examples\nAll the examples assume you’re in this directory."
  },
  {
    "objectID": "posts/00_getting_started/index.html#say-hello",
    "href": "posts/00_getting_started/index.html#say-hello",
    "title": "00: getting started",
    "section": "Say hello",
    "text": "Say hello\nYou’re now ready for a ✨Hello, World!✨"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Ambiorix is an unopinionated and minimalist web framework for R.\nIt is inspired by express.js. In fact, the syntax is almost identical, only that it is R and not JavaScript.\nAmbiorix is a server-side or back-end framework. It is not comparable to client-side frameworks like React, Angular, Vue, etc. However, it can be used in combination with those frameworks to build full stack applications."
  },
  {
    "objectID": "about.html#what-is-ambiorix",
    "href": "about.html#what-is-ambiorix",
    "title": "About",
    "section": "",
    "text": "Ambiorix is an unopinionated and minimalist web framework for R.\nIt is inspired by express.js. In fact, the syntax is almost identical, only that it is R and not JavaScript.\nAmbiorix is a server-side or back-end framework. It is not comparable to client-side frameworks like React, Angular, Vue, etc. However, it can be used in combination with those frameworks to build full stack applications."
  },
  {
    "objectID": "about.html#unopinionated-and-minimalist-what-does-that-mean",
    "href": "about.html#unopinionated-and-minimalist-what-does-that-mean",
    "title": "About",
    "section": "“Unopinionated and Minimalist”… What does that mean?",
    "text": "“Unopinionated and Minimalist”… What does that mean?\nAmbiorix does not assume you’re going to build your API (or app) in any certain way or using a certain design pattern. You have absolute full control of how you handle requests to the server and how you respond."
  },
  {
    "objectID": "about.html#so-why-should-i-use-ambiorix",
    "href": "about.html#so-why-should-i-use-ambiorix",
    "title": "About",
    "section": "So, why should I use ambiorix?",
    "text": "So, why should I use ambiorix?\n\nMakes building web applications with R VERY easy\nUsed for both server rendered apps as well as API/Microservices\nFull control of the request and response cycle\nGreat to use with your favorite client side framework (whether React, Angular, Vue etc.)"
  },
  {
    "objectID": "about.html#what-exciting-features-can-i-look-forward-to",
    "href": "about.html#what-exciting-features-can-i-look-forward-to",
    "title": "About",
    "section": "What exciting features can I look forward to?",
    "text": "What exciting features can I look forward to?\nHere are the features that make ambiorix well-suited to building large systems & applications:\n\nOut of the box routing\nCreating a robust API is quick and easy\nTemplating (html, markdown, etc.)\nWebsockets in case you need bidirectional communication"
  },
  {
    "objectID": "about.html#what-should-i-know-first",
    "href": "about.html#what-should-i-know-first",
    "title": "About",
    "section": "What should I know first?",
    "text": "What should I know first?\nThe main prerequisites are:\n\nhaving a good understanding of R fundamentals, and,\nbasic knowledge of HTTP status codes.\n\nYou can pickup most of the concepts on the go."
  },
  {
    "objectID": "about.html#package-dependencies-used-in-examples",
    "href": "about.html#package-dependencies-used-in-examples",
    "title": "About",
    "section": "Package dependencies used in examples",
    "text": "Package dependencies used in examples\nEach example has been bootstrapped using {renv} to ease reproducibility.\nTo install the dependencies for a specific example eg. 05_router:\n\nSwitch to its directory\ncd 05_router\nAdd this to the .Renviron file:\nRENV_CONFIG_SANDBOX_ENABLED = FALSE\nFire up R and restore the dependencies:\nrenv::restore()"
  },
  {
    "objectID": "posts/03_basic_routing/index.html",
    "href": "posts/03_basic_routing/index.html",
    "title": "03: basic routing",
    "section": "",
    "text": "cd into the 03_basic_routing/ dir:\ncd 03_basic_routing/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nindex.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/03_basic_routing/index.html#run-app",
    "href": "posts/03_basic_routing/index.html#run-app",
    "title": "03: basic routing",
    "section": "",
    "text": "cd into the 03_basic_routing/ dir:\ncd 03_basic_routing/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nindex.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/03_basic_routing/index.html#explanation",
    "href": "posts/03_basic_routing/index.html#explanation",
    "title": "03: basic routing",
    "section": "Explanation",
    "text": "Explanation\nThis app starts a server and listens on port 3000 for connections.\nIt has two endpoints:\n\n/\n/user\n\nRouting refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on).\nEach route can have one or more handler functions, which are executed when the route is matched.\nRoute definition takes the following structure:\napp$METHOD(PATH, HANDLER)\n\napp is an instance of ambiorix.\nMETHOD is an HTTP request method, in lowercase.\nHANDLER is the function executed when the route is matched.\n\nThe following examples illustrate defining simple routes.\nRespond with Hello World! on the homepage:\napp$get(\"/\", \\(req, res) {\n  res$send(\"Hello World!\")\n})\nRespond to POST request on the root route (/), the application’s home page:\napp$post(\"/\", \\(req, res) {\n  res$send(\"Got a POST request\")\n})\nRespond to a PUT request to the /user route:\napp$put(\"/user\", \\(req, res) {\n  res$send(\"Got a PUT request at /user\")\n})\nRespond to a DELETE request to the /user route:\napp$delete(\"/user\", \\(req, res) {\n  res$send(\"Got a DELETE request at /user\")\n})"
  },
  {
    "objectID": "posts/03_basic_routing/index.html#keep-this-in-mind",
    "href": "posts/03_basic_routing/index.html#keep-this-in-mind",
    "title": "03: basic routing",
    "section": "Keep this in mind:",
    "text": "Keep this in mind:\n\nBrowsers issue a GET request by default. This means that once you run this example and visit localhost 3000, you’ll only be able to access the homepage (/).\nThe easiest way to see the responses from the other routes would be to either:\n\nInstall Postman and make the requests from there (Recommended). The free tier is more than enough. Here is how issuing the various requests above would look like:    \nOpen another R session and use httr2 to make requests to the endpoints."
  },
  {
    "objectID": "posts/03_basic_routing/index.html#a-simple-json-api",
    "href": "posts/03_basic_routing/index.html#a-simple-json-api",
    "title": "03: basic routing",
    "section": "A simple JSON API",
    "text": "A simple JSON API\nYou’re now ready to build ✨a simple JSON API✨."
  },
  {
    "objectID": "posts/08_datatables/index.html",
    "href": "posts/08_datatables/index.html",
    "title": "08: datatables",
    "section": "",
    "text": "cd into the 08_datatables/ dir:\ncd 08_datatables/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nindex.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/08_datatables/index.html#run-app",
    "href": "posts/08_datatables/index.html#run-app",
    "title": "08: datatables",
    "section": "",
    "text": "cd into the 08_datatables/ dir:\ncd 08_datatables/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nindex.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/08_datatables/index.html#explanation",
    "href": "posts/08_datatables/index.html#explanation",
    "title": "08: datatables",
    "section": "Explanation",
    "text": "Explanation\nThis app starts a server and listens on port 3000 for connections.\nAt this point, I’m not sure there’s anything much to say :)"
  },
  {
    "objectID": "posts/08_datatables/index.html#goals",
    "href": "posts/08_datatables/index.html#goals",
    "title": "08: datatables",
    "section": "Goals",
    "text": "Goals\nAlright, time to build a ✨CRUD application backend✨."
  },
  {
    "objectID": "posts/02_static_files/index.html",
    "href": "posts/02_static_files/index.html",
    "title": "02: static files",
    "section": "",
    "text": "cd into the 02_static_files/ dir:\ncd 02_static_files/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nindex.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/02_static_files/index.html#run-app",
    "href": "posts/02_static_files/index.html#run-app",
    "title": "02: static files",
    "section": "",
    "text": "cd into the 02_static_files/ dir:\ncd 02_static_files/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nindex.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/02_static_files/index.html#explanation",
    "href": "posts/02_static_files/index.html#explanation",
    "title": "02: static files",
    "section": "Explanation",
    "text": "Explanation\nThis app starts a server and listens on port 3000 for connections.\nIt has a single endpoint:\n\n/: localhost:3000/\n\nNow that the app is running, navigate to these links in your browser:\n\nlocalhost:3000/static/index.html\nlocalhost:3000/static/about.html\nlocalhost:3000/static/index2.R\n\nTo serve static files such as images, CSS files, JavaScript files etc., use the app$static() method.\nFor example, let’s say this is your directory structure:\n|- index.R\n|- public/\n    |- index.html\n    |- about.html\n    |- image.jpg\n    |- css\n        |- styles.css\n    |- index2.R\n    |- main.js\n\n/public\nTo make the files accessible at the path /public, you’d do this:\napp$static(path = \"public\", uri = \"public\")\n\npath specifies the static directory.\nuri defines the path ambiorix should serve the static files from.\n\nSo now you’ll be able to do this in your app:\napp$get(\"/\", \\(req, res) {\n  res$send(\n    \"&lt;h1&gt;Hello everyone!&lt;/h1&gt;\n    &lt;img src='public/image.jpg'/&gt;\"\n  )\n})\nBy making the public/ folder static, any resource placed there can be accessed via the browser eg. http://localhost:3000/public/image.jpg\n\n\n/your-own-path\nYou can make static content accessible via your own custom path too.\nFor example, let’s use /static this time:\napp$static(path = \"public\", uri = \"static\")\nThen in your code you’ll use this:\napp$get(\"/\", \\(req, res) {\n  res$send(\n    \"&lt;h1&gt;Hello everyone!&lt;/h1&gt;\n    &lt;img src='static/image.jpg'/&gt;\"\n  )\n})"
  },
  {
    "objectID": "posts/02_static_files/index.html#keep-this-in-mind",
    "href": "posts/02_static_files/index.html#keep-this-in-mind",
    "title": "02: static files",
    "section": "Keep this in mind:",
    "text": "Keep this in mind:\n\nAll static files are exposed and can be accessed via the browser. DO NOT put sensitive files there.\nYou can also use htmltools tags instead of writing html strings."
  },
  {
    "objectID": "posts/02_static_files/index.html#basic-routing",
    "href": "posts/02_static_files/index.html#basic-routing",
    "title": "02: static files",
    "section": "Basic routing",
    "text": "Basic routing\nLearn the ✨basics of routing✨."
  },
  {
    "objectID": "posts/05_router/index.html",
    "href": "posts/05_router/index.html",
    "title": "05: router",
    "section": "",
    "text": "cd into the 05_router/ dir:\ncd 05_router/\n\nThere are 2 directories there: box/ & r_pkg_structure/.\ncd into any of them, say, r_pkg_structure/:\ncd r_pkg_structure/\n\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nserver.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/05_router/index.html#run-app",
    "href": "posts/05_router/index.html#run-app",
    "title": "05: router",
    "section": "",
    "text": "cd into the 05_router/ dir:\ncd 05_router/\n\nThere are 2 directories there: box/ & r_pkg_structure/.\ncd into any of them, say, r_pkg_structure/:\ncd r_pkg_structure/\n\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nserver.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/05_router/index.html#explanation",
    "href": "posts/05_router/index.html#explanation",
    "title": "05: router",
    "section": "Explanation",
    "text": "Explanation\nThis app starts a server and listens on port 3000 for connections.\nIt has two endpoints:\n\n/api/members\n/api/members/:id\n\nRouting refers to how an application’s endpoints (URIs) respond to client requests.\nFor an introduction to routing, see 03_basic_routing.\nIf you look at 04_simple_json_api you’ll notice that the routes we created all belong to /api/members and we kept repeating that base/root route.\nWouldn’t it be nice to only have to use / and /:id and have ambiorix prepend the /api/members automatically?\nThat would give you a better app structure making it manageable."
  },
  {
    "objectID": "posts/05_router/index.html#enter-ambiorixrouter.",
    "href": "posts/05_router/index.html#enter-ambiorixrouter.",
    "title": "05: router",
    "section": "Enter ambiorix::Router().",
    "text": "Enter ambiorix::Router().\nUse the ambiorix::Router class to create modular, mountable router handlers.\nA Router instance is a complete middleware and routing system; for this reason, it is often referred to as a “mini-app”.\nUsing the example 04_simple_json_api, this is how we would transform it:\n# members.R\nmembers_router &lt;- \\() {\n  router &lt;- Router$new(\"/members\")\n\n  # get all members:\n  router$get(\"/\", \\(req, res) {\n    # ...\n  })\n\n  # get a single member:\n  router$get(\"/:id\", \\(req, res) {\n    # ...\n  })\n\n  # create a new member:\n  router$post(\"/\", \\(req, res)) {\n    # ...\n  }\n\n  # update member:\n  router$put(\"/:id\", \\(req, res) {\n    # ...\n  })\n\n  # delete member:\n  router$delete(\"/:id\", \\(req, res) {\n    # ...\n  })\n\n  router\n}\nThe server.R file would now be:\nlibrary(ambiorix)\n\n# &lt;bring/import the members.R file&gt;\n\nPORT &lt;- 3000\n\napp &lt;- Ambiorix$new()\n\n# mount the router:\napp$use(members_router())\n\napp$start(port = PORT, open = FALSE)"
  },
  {
    "objectID": "posts/05_router/index.html#keep-this-in-mind",
    "href": "posts/05_router/index.html#keep-this-in-mind",
    "title": "05: router",
    "section": "Keep this in mind:",
    "text": "Keep this in mind:\nAmbiorix is unopinionated. As such, it is up to you to decide how you want to bring/export the members.R file into index.R.\nSome options are:\n\nUse box (Highly recommended, ⭐⭐⭐⭐⭐) especially if you develop large apps/systems, for two reasons:\n\nAllows nested files, folders & modules (a big win)\nExplicit name imports ie. you’re almost always sure from which package a function is from.\n\nUse R package structure (Recommended, ⭐⭐⭐⭐). Will not allow nested folders but will work really well for small to medium apps.\nsource() files (NOT recommended, 1⭐). Haha. Iykyk.\n\nChoose wisely."
  },
  {
    "objectID": "posts/05_router/index.html#multiple-routers",
    "href": "posts/05_router/index.html#multiple-routers",
    "title": "05: router",
    "section": "Multiple routers",
    "text": "Multiple routers\nLearn how you can mount ✨multiple routers✨."
  },
  {
    "objectID": "posts/09_goals/index.html",
    "href": "posts/09_goals/index.html",
    "title": "09: goals",
    "section": "",
    "text": "An installation of the community edition of MongoDB\nThe mongolite R pkg"
  },
  {
    "objectID": "posts/09_goals/index.html#prerequisites",
    "href": "posts/09_goals/index.html#prerequisites",
    "title": "09: goals",
    "section": "",
    "text": "An installation of the community edition of MongoDB\nThe mongolite R pkg"
  },
  {
    "objectID": "posts/09_goals/index.html#run-app",
    "href": "posts/09_goals/index.html#run-app",
    "title": "09: goals",
    "section": "Run app",
    "text": "Run app\n\ncd into the 09_goals/backend/ dir:\ncd 09_goals/backend/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nserver.R is the entry point. To start the app, run this on the terminal:\nRscript server.R"
  },
  {
    "objectID": "posts/09_goals/index.html#explanation",
    "href": "posts/09_goals/index.html#explanation",
    "title": "09: goals",
    "section": "Explanation",
    "text": "Explanation\nThis app starts a server and listens on port 5000 for connections.\nIn this example, we build a CRUD application backend: Goals.\nHere are the defined routes:\n\n/api:\n\nGET /goals: Get all user goals\nPOST /goals: Create a goal\nPUT /goals/:id: Update a goal\nDELETE /goals/:id: Delete a goal\n/users:\n\nPOST /: Register new user\nPOST /login: Login user\nGET /me: Get user data\n\n\n\nYou will be able to Create, Read, Update & Delete Goals.\nHere’s what’s covered:\n\nAmbiorix + MongoDB\nWorking with middleware:\n\nAuth middleware: You will learn how you can use JSON Web Tokens (JWT) to protect routes\nError handling middleware"
  },
  {
    "objectID": "posts/09_goals/index.html#live-reloading",
    "href": "posts/09_goals/index.html#live-reloading",
    "title": "09: goals",
    "section": "Live reloading",
    "text": "Live reloading\nSee how you can enable ✨live reloading✨."
  },
  {
    "objectID": "posts/07_dynamic_rendering/index.html",
    "href": "posts/07_dynamic_rendering/index.html",
    "title": "07: dynamic rendering",
    "section": "",
    "text": "cd into the 07_dynamic_rendering/ dir:\ncd 07_dynamic_rendering/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nindex.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/07_dynamic_rendering/index.html#run-app",
    "href": "posts/07_dynamic_rendering/index.html#run-app",
    "title": "07: dynamic rendering",
    "section": "",
    "text": "cd into the 07_dynamic_rendering/ dir:\ncd 07_dynamic_rendering/\nFire up R:\nR\nRestore package dependencies:\nrenv::restore()\nOnce done, exit R.\nindex.R is the entry point. To start the app, run this on the terminal:\nRscript index.R"
  },
  {
    "objectID": "posts/07_dynamic_rendering/index.html#explanation",
    "href": "posts/07_dynamic_rendering/index.html#explanation",
    "title": "07: dynamic rendering",
    "section": "Explanation",
    "text": "Explanation\nThis app starts a server and listens on port 3000 for connections.\nWhen building software, these are the available options:\n\nBuild the backend using ambiorix and the frontend using your favorite frontend framework (React, Angular, Vue, etc.)\nBuild both the back and frontend using ambiorix\n\nLet’s talk about option 2.\nFirst things first, you will be rendering html templates/files. In most cases, you want this to be done dynamically. eg. render a portion of the UI depending on whether a user is an admin or not.\nThis is what is referred to as server-side rendering (SSR).\nIn this example, I use htmx to show you how you can build interactive frontends without touching a single line of JavaScript.\nIf you know HTML then you’re all set!\nYou’ve already seen how to send HTTP requests to the server & how the server responds (with JSON so far).\nWith htmx, your responses from the server will ideally be HTML fragments.\nThis works so well with htmltools you will not believe it!"
  },
  {
    "objectID": "posts/07_dynamic_rendering/index.html#datatables",
    "href": "posts/07_dynamic_rendering/index.html#datatables",
    "title": "07: dynamic rendering",
    "section": "Datatables",
    "text": "Datatables\nWell, R people love tables. Time for you to look at ✨datatables✨."
  }
]